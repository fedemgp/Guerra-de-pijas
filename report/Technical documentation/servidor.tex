Continuando con la descripción de los módulos, se verá ahora en detalle el servidor. Este comienza creando \emph{GameLobby}, que se e encargará de aceptar conexiones que se realicen con el servidor, creando un \emph{GameLobbyAssistant} para cada uno. Esta clase recibirá los comandos que realice el cliente luego de haber tenido una conexión exitosa. Las opciones que puede realizar son crear una partida, obtener los niveles disponibles, ingresar a una partida creada y obtener una lista de partidas creadas. Todo esto sucede en  \emph{threads} separados. Tanto el GameLobby como cada GameLobbyAssistant realizan sus tareas en hilos separados, el primero para poder aceptar clientes y dejar el hilo principal para recibir el comando por \emph{stdin} necesario para comenzar el proceso de cerrado ordenado del servidor, y los segundos para que el primero pueda aceptar sin rechazar conexiones durante el lapso que el cliente tarda en comenzar una partida.\\
\indent Cuando un cliente decide crear una partida, se creará una nueva instancia de la clase \emph{Lobby}, por medio del uso de la clase \emph{Lobbies}. La clase Lobbies es una clase de importancia ya que es el \emph{recurso compartido} que relaciona todas las conexiones que se realicen al servidor. En esta se guardan todas las partidas creadas. Dado que varios clientes distintos podrían querer conectarse a la misma sala de juego, esta también posee una \emph{race condition} que debe ser tenida en cuenta. Lobbies opera como un \emph{monitor}, que realiza las operaciones de crear partida, unirse a una partida y obtener los juegos creados de forma atómica. Para esto, dispone de un mutex de protección. Lobbies posee internamente un arreglo de \emph{Lobby}, que tiene un registro de los clientes. Cuando la sala se completa, notifica al GameLobby que la partida puede comenzar. Este inmediatamente dota al Lobby de los sockets de cada cliente, para que este pueda iniciar en un hilo propio la partida. Es en este momento también que sucede la finalización de los GameLobbyAssistant involucrados. La liberación de los recursos de estas instancias (su destrucción), la realiza el GameLobby, quien revisa luego de aceptar una conexión  todos los hilos que terminaron, aplicando su correspondiente \emph{join} y su destrucción.\\
\indent La partida transcurre en la clase \emph{Game}. Esta fue pensada en un principio como una clase que iba a heredar de Thread, sin embargo, se delegó esa herencia en el Lobby que lo contiene. En esta clase se creará el mundo físico y se recibirán las interacciones que tenga el usuario con el cliente, para modificar este mundo en la medida de lo posible.\\
\indent Una vez que el juego termina, ya sea porque terminó normalmente, o porque quedó un solo jugador conectado, se debe proceder a realizar un \emph{join} del hilo. De esto se encarga el\emph{LobbyJoiner}. Este proceso, que opera en un hilo aparte, se encarga de iterar sobre los Lobby terminados, para realizar un join y eliminarlo del arreglo. A primera vista, pareciera que este ciclo ocurre indefinidamente, pudiendo consumir una cantidad de recursos considerable de la computadora. Sin embargo, el GameLobby se comunica con esta clase mediante una cola bloqueante. Esta le manda mensajes al LobbyJoiner cuando una partida termina, para que este se active y libere el recurso.

\subsection{Desarrollo del juego}
Durante el juego, que transcurre en la clase Game, los distintos clientes son tratados con dos hilos para cada uno, uno que se encarga de recibir datos del cliente (por medio del método \emph{inputWorker}) y otra que se encarga de enviarle el estado del juego (por medio del método \emph{outputWorker}). Estos métodos de la instancia Game se encargan de \emph{serializar} y \emph{deserializar} los mensajes que envía y los que recibe del cliente.

\subsection{Clases}

Se describen ahora las clases utilizadas en el servidor.

\begin{itemize}
	\item \textbf{\textit{CommunicationSocket}}: clase que se usa para comunicarse con el cliente. Tiene la posibilidad de enviar y recibir mensajes, y es devuelta por movimiento cuando se acepta una conexión. En el cliente se usa indirectamente, ya que es padre de la clase \textit{ClientSocket}, la cual tiene la capacidad de realizar un \textit{connect} al servidor. Sus métodos son \textit{send} y \textit{receive}, utilizados para enviar y recibir información por el \textit{socket} respectivamente.
	
	\item \textbf{\textit{ServerSocket}}: acepta una conexión y devuelve un \textit{CommunicationSocket} por movimiento. Sus métodos son \textit{bindAndListen}, donde se \textit{bindea} a un puerto y escucha conexiones, y \textit{accept}, que hace lo explicado anteriormente.
	
	\item \textbf{\textit{ServerInternalAction}}: clase \textit{enum} que posee las acciones que internamente el servidor envía en \textit{GameLobby} a \textit{LobbyJoiner}.
	
	\item \textbf{\textit{ServerInternalMsg}}: es una estructura que posee un \textit{ServerInternalAction}. Es un mensaje que envía \textit{GameLobby} a \textit{LobbyJoiner}.
	
	\item \textbf{\textit{Chronometer}}: es una clase que encapsula el cálculo del tiempo transcurrido entre distintas llamadas a su método \textit{elapsed}, que devuelve el valor de dicho tiempo.
	
	\item \textbf{\textit{GameClock}}: cuenta el tiempo de los turnos del juego y responde a distintos eventos del mismo, que modifican su valor. Hereda de \textit{Subject}, y notificará eventos al \textit{Game}. En su construcción toma de la configuración los valores correspondientes a la duración de un turno, el tiempo extra que recibe un jugador al disparar, y el tiempo que se deja pasar entre turno y turno para mejorar la dinámica del juego. El método \textit{playerShot} pone el tiempo transcurrido en cero y el tiempo actual del turno en el tiempo extra que corresponde al jugador luego de disparar. Cuando el juego establece que el turno ha terminado (ya sea por el final del tiempo u otro evento como que el gusano activo sufre daño), llama al método \textit{waitForNextTurn}, que pone el tiempo transcurrido en cero, el tiempo que debe transcurrir igual al correspondiente a la espera entre turno y turno, y setea un \textit{flag}. Hace uso de este último en su método \textit{update}, donde recibe el tiempo transcurrido desde su última llamada y lo acumula en un atributo, y si su valor supera al tiempo que posee el jugador actualmente, se notifica o bien que el turno terminó en lo que respecta al tiempo, o bien que el turno siguiente debe comenzar si el \textit{flag} está seteado. El método \textit{endTurn} fuerza el reloj a terminar y notificar un evento de fin de turno, por ejemplo cuando el gusano activo sufre daño al caerse de una altura determinada. El método \textit{restart} vuelve el tiempo acumulado a cero, quita el \textit{flag} de espera del siguiente turno y establece el tiempo de turno en su valor original.
\end{itemize}